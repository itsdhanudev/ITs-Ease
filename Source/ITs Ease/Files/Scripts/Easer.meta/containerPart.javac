package JAVARuntime;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.concurrent.locks.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import java.util.zip.*;
import java.text.*;
import java.net.*;
import java.math.*;
import java.io.*;
import java.nio.*;
import java.time.*;
import java.time.chrono.*;
import java.time.format.*;
import java.time.temporal.*;
import java.time.zone.*;



public class _JContainer{}

//C-R:Easer
final class Easer { //[I-S]LN=0;[I-E]
  private Easer() {} //[I-S]LN=1;[I-E]
 //[I-S]LN=2;[I-E]
  public static float ease(float start, float end, float t, EasingTypes type) { //[I-S]LN=3;[I-E]
    switch (type) { //[I-S]LN=4;[I-E]
      case Linear: //[I-S]LN=5;[I-E]
        return EasingFunctions.linear(start, end, t); //[I-S]LN=6;[I-E]
      case EaseInQuad: //[I-S]LN=7;[I-E]
        return EasingFunctions.easeInQuad(start, end, t); //[I-S]LN=8;[I-E]
      case EaseOutQuad: //[I-S]LN=9;[I-E]
        return EasingFunctions.easeOutQuad(start, end, t); //[I-S]LN=10;[I-E]
      case EaseInOutQuad: //[I-S]LN=11;[I-E]
        return EasingFunctions.easeInOutQuad(start, end, t); //[I-S]LN=12;[I-E]
      case EaseInCubic: //[I-S]LN=13;[I-E]
        return EasingFunctions.easeInCubic(start, end, t); //[I-S]LN=14;[I-E]
      case EaseOutCubic: //[I-S]LN=15;[I-E]
        return EasingFunctions.easeOutCubic(start, end, t); //[I-S]LN=16;[I-E]
      case EaseInOutCubic: //[I-S]LN=17;[I-E]
        return EasingFunctions.easeInOutCubic(start, end, t); //[I-S]LN=18;[I-E]
      case EaseInQuart: //[I-S]LN=19;[I-E]
        return EasingFunctions.easeInQuart(start, end, t); //[I-S]LN=20;[I-E]
      case EaseOutQuart: //[I-S]LN=21;[I-E]
        return EasingFunctions.easeOutQuart(start, end, t); //[I-S]LN=22;[I-E]
      case EaseInOutQuart: //[I-S]LN=23;[I-E]
        return EasingFunctions.easeInOutQuart(start, end, t); //[I-S]LN=24;[I-E]
      case EaseInQuint: //[I-S]LN=25;[I-E]
        return EasingFunctions.easeInQuint(start, end, t); //[I-S]LN=26;[I-E]
      case EaseOutQuint: //[I-S]LN=27;[I-E]
        return EasingFunctions.easeOutQuint(start, end, t); //[I-S]LN=28;[I-E]
      case EaseInOutQuint: //[I-S]LN=29;[I-E]
        return EasingFunctions.easeInOutQuint(start, end, t); //[I-S]LN=30;[I-E]
      case EaseInSine: //[I-S]LN=31;[I-E]
        return EasingFunctions.easeInSine(start, end, t); //[I-S]LN=32;[I-E]
      case EaseOutSine: //[I-S]LN=33;[I-E]
        return EasingFunctions.easeOutSine(start, end, t); //[I-S]LN=34;[I-E]
      case EaseInOutSine: //[I-S]LN=35;[I-E]
        return EasingFunctions.easeInOutSine(start, end, t); //[I-S]LN=36;[I-E]
      case EaseInExpo: //[I-S]LN=37;[I-E]
        return EasingFunctions.easeInExpo(start, end, t); //[I-S]LN=38;[I-E]
      case EaseOutExpo: //[I-S]LN=39;[I-E]
        return EasingFunctions.easeOutExpo(start, end, t); //[I-S]LN=40;[I-E]
      case EaseInOutExpo: //[I-S]LN=41;[I-E]
        return EasingFunctions.easeInOutExpo(start, end, t); //[I-S]LN=42;[I-E]
      case EaseInCirc: //[I-S]LN=43;[I-E]
        return EasingFunctions.easeInCirc(start, end, t); //[I-S]LN=44;[I-E]
      case EaseOutCirc: //[I-S]LN=45;[I-E]
        return EasingFunctions.easeOutCirc(start, end, t); //[I-S]LN=46;[I-E]
      case EaseInOutCirc: //[I-S]LN=47;[I-E]
        return EasingFunctions.easeInOutCirc(start, end, t); //[I-S]LN=48;[I-E]
      case EaseInBack: //[I-S]LN=49;[I-E]
        return EasingFunctions.easeInBack(start, end, t); //[I-S]LN=50;[I-E]
      case EaseOutBack: //[I-S]LN=51;[I-E]
        return EasingFunctions.easeOutBack(start, end, t); //[I-S]LN=52;[I-E]
      case EaseInOutBack: //[I-S]LN=53;[I-E]
        return EasingFunctions.easeInOutBack(start, end, t); //[I-S]LN=54;[I-E]
      case EaseOutBounce: //[I-S]LN=55;[I-E]
        return EasingFunctions.easeOutBounce(start, end, t); //[I-S]LN=56;[I-E]
      case EaseInBounce: //[I-S]LN=57;[I-E]
        return EasingFunctions.easeInBounce(start, end, t); //[I-S]LN=58;[I-E]
      case EaseInOutBounce: //[I-S]LN=59;[I-E]
        return EasingFunctions.easeInOutBounce(start, end, t); //[I-S]LN=60;[I-E]
      case EaseInElastic: //[I-S]LN=61;[I-E]
        return EasingFunctions.easeInElastic(start, end, t); //[I-S]LN=62;[I-E]
      case EaseOutElastic: //[I-S]LN=63;[I-E]
        return EasingFunctions.easeOutElastic(start, end, t); //[I-S]LN=64;[I-E]
      case EaseInOutElastic: //[I-S]LN=65;[I-E]
        return EasingFunctions.easeInOutElastic(start, end, t); //[I-S]LN=66;[I-E]
      case SmoothStep: //[I-S]LN=67;[I-E]
        return EasingFunctions.smoothStep(start, end, t); //[I-S]LN=68;[I-E]
      case SmootherStep: //[I-S]LN=69;[I-E]
        return EasingFunctions.smootherStep(start, end, t); //[I-S]LN=70;[I-E]
      default: //[I-S]LN=71;[I-E]
        return start; // fallback //[I-S]LN=72;[I-E]
    } //[I-S]LN=73;[I-E]
  } //[I-S]LN=74;[I-E]
 //[I-S]LN=75;[I-E]
  public static float ease(float start, float end, float t, Curve curve) { //[I-S]LN=76;[I-E]
      return EasingFunctions.linear(start,end,curve.evaluate(t)); //[I-S]LN=77;[I-E]
  }  //[I-S]LN=78;[I-E]
 //[I-S]LN=79;[I-E]
  public static Vector2 easeVec(Vector2 start, Vector2 end, float t, EasingTypes type) { //[I-S]LN=80;[I-E]
    Vector2 desiredVec = new Vector2(ease(start.getX(), end.getX(), t, type), ease(start.getY(), end.getY(), t, type)); //[I-S]LN=81;[I-E]
    return desiredVec; //[I-S]LN=82;[I-E]
  } //[I-S]LN=83;[I-E]
 //[I-S]LN=84;[I-E]
  public static Vector3 easeVec(Vector3 start, Vector3 end, float t, EasingTypes type) { //[I-S]LN=85;[I-E]
    Vector3 desiredVec = new Vector3(ease(start.getX(), end.getX(), t, type), ease(start.getY(), end.getY(), t, type), ease(start.getZ(), end.getZ(), t, type)); //[I-S]LN=86;[I-E]
    return desiredVec; //[I-S]LN=87;[I-E]
  } //[I-S]LN=88;[I-E]
   //[I-S]LN=89;[I-E]
  public static Vector2 easeVec(Vector2 start, Vector2 end, float t, Curve curve) { //[I-S]LN=90;[I-E]
    Vector2 desiredVec = new Vector2(ease(start.getX(), end.getX(), t, curve), ease(start.getY(), end.getY(), t, curve)); //[I-S]LN=91;[I-E]
    return desiredVec; //[I-S]LN=92;[I-E]
  } //[I-S]LN=93;[I-E]
 //[I-S]LN=94;[I-E]
  public static Vector3 easeVec(Vector3 start, Vector3 end, float t, Curve curve) { //[I-S]LN=95;[I-E]
    Vector3 desiredVec = new Vector3(ease(start.getX(), end.getX(), t,curve), ease(start.getY(), end.getY(), t, curve), ease(start.getZ(), end.getZ(), t, curve)); //[I-S]LN=96;[I-E]
    return desiredVec; //[I-S]LN=97;[I-E]
  } //[I-S]LN=98;[I-E]
 //[I-S]LN=99;[I-E]
  public static Quaternion easeQua(Vector3 start, Vector3 end, float t, EasingTypes type) { //[I-S]LN=100;[I-E]
    Quaternion desiredQua; //[I-S]LN=101;[I-E]
    desiredQua = Quaternion.fromEuler(new Vector3(ease(start.getX(), end.getX(), t, type), ease(start.getY(), end.getY(), t, type), ease(start.getZ(), end.getZ(), t, type))); //[I-S]LN=102;[I-E]
    return desiredQua; //[I-S]LN=103;[I-E]
  } //[I-S]LN=104;[I-E]
   //[I-S]LN=105;[I-E]
  public static Quaternion easeQua(Vector3 start, Vector3 end, float t, Curve curve) { //[I-S]LN=106;[I-E]
    Quaternion desiredQua; //[I-S]LN=107;[I-E]
    desiredQua = Quaternion.fromEuler(new Vector3(ease(start.getX(), end.getX(), t, curve), ease(start.getY(), end.getY(), t, curve), ease(start.getZ(), end.getZ(), t, curve))); //[I-S]LN=108;[I-E]
    return desiredQua; //[I-S]LN=109;[I-E]
  } //[I-S]LN=110;[I-E]
  /* //[I-S]LN=111;[I-E]
   * still finding a btter ways to use easings which more parameters //[I-S]LN=112;[I-E]
   */ //[I-S]LN=113;[I-E]
  /* //[I-S]LN=114;[I-E]
  public static float ease(float start, float end, float t, EasingTypes type, float... params) { //[I-S]LN=115;[I-E]
    switch (type) { //[I-S]LN=116;[I-E]
      case Linear: //[I-S]LN=117;[I-E]
        return EasingFunctions.linear(start, end, t); //[I-S]LN=118;[I-E]
      case EaseInQuad: //[I-S]LN=119;[I-E]
        return EasingFunctions.easeInQuad(start, end, t); //[I-S]LN=120;[I-E]
      case EaseOutQuad: //[I-S]LN=121;[I-E]
        return EasingFunctions.easeOutQuad(start, end, t); //[I-S]LN=122;[I-E]
      case EaseInOutQuad: //[I-S]LN=123;[I-E]
        return EasingFunctions.easeInOutQuad(start, end, t); //[I-S]LN=124;[I-E]
      case EaseInCubic: //[I-S]LN=125;[I-E]
        return EasingFunctions.easeInCubic(start, end, t); //[I-S]LN=126;[I-E]
      case EaseOutCubic: //[I-S]LN=127;[I-E]
        return EasingFunctions.easeOutCubic(start, end, t); //[I-S]LN=128;[I-E]
      case EaseInOutCubic: //[I-S]LN=129;[I-E]
        return EasingFunctions.easeInOutCubic(start, end, t); //[I-S]LN=130;[I-E]
      case EaseInQuart: //[I-S]LN=131;[I-E]
        return EasingFunctions.easeInQuart(start, end, t); //[I-S]LN=132;[I-E]
      case EaseOutQuart: //[I-S]LN=133;[I-E]
        return EasingFunctions.easeOutQuart(start, end, t); //[I-S]LN=134;[I-E]
      case EaseInOutQuart: //[I-S]LN=135;[I-E]
        return EasingFunctions.easeInOutQuart(start, end, t); //[I-S]LN=136;[I-E]
      case EaseInQuint: //[I-S]LN=137;[I-E]
        return EasingFunctions.easeInQuint(start, end, t); //[I-S]LN=138;[I-E]
      case EaseOutQuint: //[I-S]LN=139;[I-E]
        return EasingFunctions.easeOutQuint(start, end, t); //[I-S]LN=140;[I-E]
      case EaseInOutQuint: //[I-S]LN=141;[I-E]
        return EasingFunctions.easeInOutQuint(start, end, t); //[I-S]LN=142;[I-E]
      case EaseInSine: //[I-S]LN=143;[I-E]
        return EasingFunctions.easeInSine(start, end, t); //[I-S]LN=144;[I-E]
      case EaseOutSine: //[I-S]LN=145;[I-E]
        return EasingFunctions.easeOutSine(start, end, t); //[I-S]LN=146;[I-E]
      case EaseInOutSine: //[I-S]LN=147;[I-E]
        return EasingFunctions.easeInOutSine(start, end, t); //[I-S]LN=148;[I-E]
      case EaseInExpo: //[I-S]LN=149;[I-E]
        return EasingFunctions.easeInExpo(start, end, t); //[I-S]LN=150;[I-E]
      case EaseOutExpo: //[I-S]LN=151;[I-E]
        return EasingFunctions.easeOutExpo(start, end, t); //[I-S]LN=152;[I-E]
      case EaseInOutExpo: //[I-S]LN=153;[I-E]
        return EasingFunctions.easeInOutExpo(start, end, t); //[I-S]LN=154;[I-E]
      case EaseInCirc: //[I-S]LN=155;[I-E]
        return EasingFunctions.easeInCirc(start, end, t); //[I-S]LN=156;[I-E]
      case EaseOutCirc: //[I-S]LN=157;[I-E]
        return EasingFunctions.easeOutCirc(start, end, t); //[I-S]LN=158;[I-E]
      case EaseInOutCirc: //[I-S]LN=159;[I-E]
        return EasingFunctions.easeInOutCirc(start, end, t); //[I-S]LN=160;[I-E]
      case EaseInBack: //[I-S]LN=161;[I-E]
        return EasingFunctions.easeInBack(start, end, t); //[I-S]LN=162;[I-E]
      case EaseOutBack: //[I-S]LN=163;[I-E]
        return EasingFunctions.easeOutBack(start, end, t); //[I-S]LN=164;[I-E]
      case EaseInOutBack: //[I-S]LN=165;[I-E]
        return EasingFunctions.easeInOutBack(start, end, t); //[I-S]LN=166;[I-E]
      case EaseOutBounce: //[I-S]LN=167;[I-E]
        return EasingFunctions.easeOutBounce(start, end, t); //[I-S]LN=168;[I-E]
      case EaseInBounce: //[I-S]LN=169;[I-E]
        return EasingFunctions.easeInBounce(start, end, t); //[I-S]LN=170;[I-E]
      case EaseInOutBounce: //[I-S]LN=171;[I-E]
        return EasingFunctions.easeInOutBounce(start, end, t); //[I-S]LN=172;[I-E]
      case EaseInElastic: //[I-S]LN=173;[I-E]
        return EasingFunctions.easeInElastic(start, end, t); //[I-S]LN=174;[I-E]
      case EaseOutElastic: //[I-S]LN=175;[I-E]
        return EasingFunctions.easeOutElastic(start, end, t); //[I-S]LN=176;[I-E]
      case EaseInOutElastic: //[I-S]LN=177;[I-E]
        return EasingFunctions.easeInOutElastic(start, end, t); //[I-S]LN=178;[I-E]
      case SmoothStep: //[I-S]LN=179;[I-E]
        return EasingFunctions.smoothStep(start, end, t); //[I-S]LN=180;[I-E]
      case SmootherStep: //[I-S]LN=181;[I-E]
        return EasingFunctions.smootherStep(start, end, t); //[I-S]LN=182;[I-E]
      default: //[I-S]LN=183;[I-E]
        return start; // fallback //[I-S]LN=184;[I-E]
    } //[I-S]LN=185;[I-E]
  } //[I-S]LN=186;[I-E]
  */ //[I-S]LN=187;[I-E]
 //[I-S]LN=188;[I-E]
} //[I-S]LN=189;[I-E]
//C-R:EasingFunctions
/* @Author Dhanu */  //[I-S]LN=0;[I-E]
class EasingFunctions{ //[I-S]LN=1;[I-E]
    //[I-S]LN=2;[I-E]
  private static float clamp01(float t) { //[I-S]LN=3;[I-E]
    if (t <= 0.0f) return 0.0f; //[I-S]LN=4;[I-E]
    if (t >= 1.0f) return 1.0f; //[I-S]LN=5;[I-E]
    return t; //[I-S]LN=6;[I-E]
  } //[I-S]LN=7;[I-E]
 //[I-S]LN=8;[I-E]
  public static float linear(float start, float end, float t) { //[I-S]LN=9;[I-E]
    return start + (end - start) * t; //[I-S]LN=10;[I-E]
  } //[I-S]LN=11;[I-E]
 //[I-S]LN=12;[I-E]
  public static float easeInQuad(float start, float end, float t) { //[I-S]LN=13;[I-E]
    return start + (end - start) * (t * t); //[I-S]LN=14;[I-E]
  } //[I-S]LN=15;[I-E]
 //[I-S]LN=16;[I-E]
  public static float easeOutQuad(float start, float end, float t) { //[I-S]LN=17;[I-E]
    return start - (end - start) * (t * (t - 2.0f)); //[I-S]LN=18;[I-E]
  } //[I-S]LN=19;[I-E]
 //[I-S]LN=20;[I-E]
  public static float easeInOutQuad(float start, float end, float t) { //[I-S]LN=21;[I-E]
    t *= 2.0f; //[I-S]LN=22;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (t * t); //[I-S]LN=23;[I-E]
    t -= 1.0f; //[I-S]LN=24;[I-E]
    return start - (end - start) / 2.0f * (t * (t - 2.0f) - 1.0f); //[I-S]LN=25;[I-E]
  } //[I-S]LN=26;[I-E]
 //[I-S]LN=27;[I-E]
  public static float easeInCubic(float start, float end, float t) { //[I-S]LN=28;[I-E]
    return start + (end - start) * (t * t * t); //[I-S]LN=29;[I-E]
  } //[I-S]LN=30;[I-E]
 //[I-S]LN=31;[I-E]
  public static float easeOutCubic(float start, float end, float t) { //[I-S]LN=32;[I-E]
    t -= 1.0f; //[I-S]LN=33;[I-E]
    return start + (end - start) * (t * t * t + 1.0f); //[I-S]LN=34;[I-E]
  } //[I-S]LN=35;[I-E]
 //[I-S]LN=36;[I-E]
  public static float easeInOutCubic(float start, float end, float t) { //[I-S]LN=37;[I-E]
    t *= 2.0f; //[I-S]LN=38;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (t * t * t); //[I-S]LN=39;[I-E]
    t -= 2.0f; //[I-S]LN=40;[I-E]
    return start + (end - start) / 2.0f * (t * t * t + 2.0f); //[I-S]LN=41;[I-E]
  } //[I-S]LN=42;[I-E]
 //[I-S]LN=43;[I-E]
  public static float easeInQuart(float start, float end, float t) { //[I-S]LN=44;[I-E]
    return start + (end - start) * (t * t * t * t); //[I-S]LN=45;[I-E]
  } //[I-S]LN=46;[I-E]
 //[I-S]LN=47;[I-E]
  public static float easeOutQuart(float start, float end, float t) { //[I-S]LN=48;[I-E]
    t -= 1.0f; //[I-S]LN=49;[I-E]
    return start - (end - start) * (t * t * t * t - 1.0f); //[I-S]LN=50;[I-E]
  } //[I-S]LN=51;[I-E]
 //[I-S]LN=52;[I-E]
  public static float easeInOutQuart(float start, float end, float t) { //[I-S]LN=53;[I-E]
    t *= 2.0f; //[I-S]LN=54;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (t * t * t * t); //[I-S]LN=55;[I-E]
    t -= 2.0f; //[I-S]LN=56;[I-E]
    return start - (end - start) / 2.0f * (t * t * t * t - 2.0f); //[I-S]LN=57;[I-E]
  } //[I-S]LN=58;[I-E]
 //[I-S]LN=59;[I-E]
  public static float easeInQuint(float start, float end, float t) { //[I-S]LN=60;[I-E]
    return start + (end - start) * (t * t * t * t * t); //[I-S]LN=61;[I-E]
  } //[I-S]LN=62;[I-E]
 //[I-S]LN=63;[I-E]
  public static float easeOutQuint(float start, float end, float t) { //[I-S]LN=64;[I-E]
    t -= 1.0f; //[I-S]LN=65;[I-E]
    return start + (end - start) * (t * t * t * t * t + 1.0f); //[I-S]LN=66;[I-E]
  } //[I-S]LN=67;[I-E]
 //[I-S]LN=68;[I-E]
  public static float easeInOutQuint(float start, float end, float t) { //[I-S]LN=69;[I-E]
    t *= 2.0f; //[I-S]LN=70;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (t * t * t * t * t); //[I-S]LN=71;[I-E]
    t -= 2.0f; //[I-S]LN=72;[I-E]
    return start + (end - start) / 2.0f * (t * t * t * t * t + 2.0f); //[I-S]LN=73;[I-E]
  } //[I-S]LN=74;[I-E]
 //[I-S]LN=75;[I-E]
  public static float easeInSine(float start, float end, float t) { //[I-S]LN=76;[I-E]
    return start - (end - start) * (float) Math.cos(t * Math.PI / 2.0f) + (end - start); //[I-S]LN=77;[I-E]
  } //[I-S]LN=78;[I-E]
 //[I-S]LN=79;[I-E]
  public static float easeOutSine(float start, float end, float t) { //[I-S]LN=80;[I-E]
    return start + (end - start) * (float) Math.sin(t * Math.PI / 2.0f); //[I-S]LN=81;[I-E]
  } //[I-S]LN=82;[I-E]
 //[I-S]LN=83;[I-E]
  public static float easeInOutSine(float start, float end, float t) { //[I-S]LN=84;[I-E]
    return start - (end - start) / 2.0f * ((float) Math.cos(Math.PI * t) - 1.0f); //[I-S]LN=85;[I-E]
  } //[I-S]LN=86;[I-E]
 //[I-S]LN=87;[I-E]
  public static float easeInExpo(float start, float end, float t) { //[I-S]LN=88;[I-E]
    if (t == 0.0f) return start; //[I-S]LN=89;[I-E]
    return start + (end - start) * (float) Math.pow(2.0f, 10.0f * (t - 1.0f)); //[I-S]LN=90;[I-E]
  } //[I-S]LN=91;[I-E]
 //[I-S]LN=92;[I-E]
  public static float easeOutExpo(float start, float end, float t) { //[I-S]LN=93;[I-E]
    if (t == 1.0f) return end; //[I-S]LN=94;[I-E]
    return start + (end - start) * (-(float) Math.pow(2.0f, -10.0f * t) + 1.0f); //[I-S]LN=95;[I-E]
  } //[I-S]LN=96;[I-E]
 //[I-S]LN=97;[I-E]
  public static float easeInOutExpo(float start, float end, float t) { //[I-S]LN=98;[I-E]
    if (t == 0.0f) return start; //[I-S]LN=99;[I-E]
    if (t == 1.0f) return end; //[I-S]LN=100;[I-E]
    t *= 2.0f; //[I-S]LN=101;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (float) Math.pow(2.0f, 10.0f * (t - 1.0f)); //[I-S]LN=102;[I-E]
    t -= 1.0f; //[I-S]LN=103;[I-E]
    return start + (end - start) / 2.0f * (-(float) Math.pow(2.0f, -10.0f * t) + 2.0f); //[I-S]LN=104;[I-E]
  } //[I-S]LN=105;[I-E]
 //[I-S]LN=106;[I-E]
  public static float easeInCirc(float start, float end, float t) { //[I-S]LN=107;[I-E]
    return start - (end - start) * ((float) Math.sqrt(1.0f - t * t) - 1.0f); //[I-S]LN=108;[I-E]
  } //[I-S]LN=109;[I-E]
 //[I-S]LN=110;[I-E]
  public static float easeOutCirc(float start, float end, float t) { //[I-S]LN=111;[I-E]
    t -= 1.0f; //[I-S]LN=112;[I-E]
    return start + (end - start) * (float) Math.sqrt(1.0f - t * t); //[I-S]LN=113;[I-E]
  } //[I-S]LN=114;[I-E]
 //[I-S]LN=115;[I-E]
  public static float easeInOutCirc(float start, float end, float t) { //[I-S]LN=116;[I-E]
    t *= 2.0f; //[I-S]LN=117;[I-E]
    if (t < 1.0f) return start - (end - start) / 2.0f * ((float) Math.sqrt(1.0f - t * t) - 1.0f); //[I-S]LN=118;[I-E]
    t -= 2.0f; //[I-S]LN=119;[I-E]
    return start + (end - start) / 2.0f * ((float) Math.sqrt(1.0f - t * t) + 1.0f); //[I-S]LN=120;[I-E]
  } //[I-S]LN=121;[I-E]
 //[I-S]LN=122;[I-E]
  public static float easeInBack(float start, float end, float t) { //[I-S]LN=123;[I-E]
    float s = 1.70158f; //[I-S]LN=124;[I-E]
    return start + (end - start) * (t * t * ((s + 1.0f) * t - s)); //[I-S]LN=125;[I-E]
  } //[I-S]LN=126;[I-E]
 //[I-S]LN=127;[I-E]
  public static float easeOutBack(float start, float end, float t) { //[I-S]LN=128;[I-E]
    float s = 1.70158f; //[I-S]LN=129;[I-E]
    t -= 1.0f; //[I-S]LN=130;[I-E]
    return start + (end - start) * (t * t * ((s + 1.0f) * t + s) + 1.0f); //[I-S]LN=131;[I-E]
  } //[I-S]LN=132;[I-E]
 //[I-S]LN=133;[I-E]
  public static float easeInOutBack(float start, float end, float t) { //[I-S]LN=134;[I-E]
    float s = 1.70158f * 1.525f; //[I-S]LN=135;[I-E]
    t *= 2.0f; //[I-S]LN=136;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (t * t * ((s + 1.0f) * t - s)); //[I-S]LN=137;[I-E]
    t -= 2.0f; //[I-S]LN=138;[I-E]
    return start + (end - start) / 2.0f * (t * t * ((s + 1.0f) * t + s) + 2.0f); //[I-S]LN=139;[I-E]
  } //[I-S]LN=140;[I-E]
 //[I-S]LN=141;[I-E]
  public static float easeOutBounce(float start, float end, float t) { //[I-S]LN=142;[I-E]
    float n1 = 7.5625f; //[I-S]LN=143;[I-E]
    float d1 = 2.75f; //[I-S]LN=144;[I-E]
    float diff = (end - start); //[I-S]LN=145;[I-E]
    if (t < 1.0f / d1) { //[I-S]LN=146;[I-E]
      return start + diff * (n1 * t * t); //[I-S]LN=147;[I-E]
    } else if (t < 2.0f / d1) { //[I-S]LN=148;[I-E]
      t -= 1.5f / d1; //[I-S]LN=149;[I-E]
      return start + diff * (n1 * t * t + 0.75f); //[I-S]LN=150;[I-E]
    } else if (t < 2.5f / d1) { //[I-S]LN=151;[I-E]
      t -= 2.25f / d1; //[I-S]LN=152;[I-E]
      return start + diff * (n1 * t * t + 0.9375f); //[I-S]LN=153;[I-E]
    } else { //[I-S]LN=154;[I-E]
      t -= 2.625f / d1; //[I-S]LN=155;[I-E]
      return start + diff * (n1 * t * t + 0.984375f); //[I-S]LN=156;[I-E]
    } //[I-S]LN=157;[I-E]
  } //[I-S]LN=158;[I-E]
 //[I-S]LN=159;[I-E]
  public static float easeInBounce(float start, float end, float t) { //[I-S]LN=160;[I-E]
    float inv = easeOutBounce(0.0f, 1.0f, 1.0f - t); //[I-S]LN=161;[I-E]
    return start + (end - start) * (1.0f - inv); //[I-S]LN=162;[I-E]
  } //[I-S]LN=163;[I-E]
 //[I-S]LN=164;[I-E]
  public static float easeInOutBounce(float start, float end, float t) { //[I-S]LN=165;[I-E]
    if (t < 0.5f) return start + (end - start) * 0.5f * (1.0f - easeOutBounce(0.0f, 1.0f, 1.0f - (t * 2.0f))); //[I-S]LN=166;[I-E]
    else return start + (end - start) * (0.5f * easeOutBounce(0.0f, 1.0f, (t * 2.0f - 1.0f)) + 0.5f); //[I-S]LN=167;[I-E]
  } //[I-S]LN=168;[I-E]
 //[I-S]LN=169;[I-E]
  public static float easeInElastic(float start, float end, float t) { //[I-S]LN=170;[I-E]
    if (t == 0.0f) return start; //[I-S]LN=171;[I-E]
    if (t == 1.0f) return end; //[I-S]LN=172;[I-E]
    float p = 0.3f; //[I-S]LN=173;[I-E]
    float s = p / 4.0f; //[I-S]LN=174;[I-E]
    t -= 1.0f; //[I-S]LN=175;[I-E]
    return start + -(end - start) * (float) Math.pow(2.0f, 10.0f * t) * (float) Math.sin((t - s) * (2.0f * Math.PI) / p); //[I-S]LN=176;[I-E]
  } //[I-S]LN=177;[I-E]
 //[I-S]LN=178;[I-E]
  public static float easeOutElastic(float start, float end, float t) { //[I-S]LN=179;[I-E]
    if (t == 0.0f) return start; //[I-S]LN=180;[I-E]
    if (t == 1.0f) return end; //[I-S]LN=181;[I-E]
    float p = 0.3f; //[I-S]LN=182;[I-E]
    float s = p / 4.0f; //[I-S]LN=183;[I-E]
    return start + (end - start) * ((float) Math.pow(2.0f, -10.0f * t) * (float) Math.sin((t - s) * (2.0f * Math.PI) / p) + 1.0f); //[I-S]LN=184;[I-E]
  } //[I-S]LN=185;[I-E]
 //[I-S]LN=186;[I-E]
  public static float easeInOutElastic(float start, float end, float t) { //[I-S]LN=187;[I-E]
    if (t == 0.0f) return start; //[I-S]LN=188;[I-E]
    if (t == 1.0f) return end; //[I-S]LN=189;[I-E]
    float p = 0.45f; //[I-S]LN=190;[I-E]
    float s = p / 4.0f; //[I-S]LN=191;[I-E]
    t *= 2.0f; //[I-S]LN=192;[I-E]
    if (t < 1.0f) { //[I-S]LN=193;[I-E]
      t -= 1.0f; //[I-S]LN=194;[I-E]
      return start + -(end - start) / 2.0f * (float) Math.pow(2.0f, 10.0f * t) * (float) Math.sin((t - s) * (2.0f * Math.PI) / p); //[I-S]LN=195;[I-E]
    } else { //[I-S]LN=196;[I-E]
      t -= 1.0f; //[I-S]LN=197;[I-E]
      return start + (end - start) / 2.0f * ((float) Math.pow(2.0f, -10.0f * t) * (float) Math.sin((t - s) * (2.0f * Math.PI) / p) + 1.0f); //[I-S]LN=198;[I-E]
    } //[I-S]LN=199;[I-E]
  } //[I-S]LN=200;[I-E]
 //[I-S]LN=201;[I-E]
  public static float smoothStep(float start, float end, float t) { //[I-S]LN=202;[I-E]
    t = clamp01(t); //[I-S]LN=203;[I-E]
    return start + (end - start) * (t * t * (3.0f - 2.0f * t)); //[I-S]LN=204;[I-E]
  } //[I-S]LN=205;[I-E]
 //[I-S]LN=206;[I-E]
  public static float smootherStep(float start, float end, float t) { //[I-S]LN=207;[I-E]
    t = clamp01(t); //[I-S]LN=208;[I-E]
    return start + (end - start) * (t * t * t * (t * (6.0f * t - 15.0f) + 10.0f)); //[I-S]LN=209;[I-E]
  } //[I-S]LN=210;[I-E]
 //[I-S]LN=211;[I-E]
  public static float step(float start, float end, float t, int steps) { //[I-S]LN=212;[I-E]
    if (steps <= 1) return (t < 0.5f ? start : end); //[I-S]LN=213;[I-E]
    t = clamp01(t); //[I-S]LN=214;[I-E]
    float stepT = (float) Math.floor(t * steps) / (float) steps; //[I-S]LN=215;[I-E]
    return start + (end - start) * stepT; //[I-S]LN=216;[I-E]
  } //[I-S]LN=217;[I-E]
 //[I-S]LN=218;[I-E]
  public static float easeInPower(float start, float end, float t, int n) { //[I-S]LN=219;[I-E]
    if (n <= 1) return linear(start, end, t); //[I-S]LN=220;[I-E]
    return start + (end - start) * (float) Math.pow(t, n); //[I-S]LN=221;[I-E]
  } //[I-S]LN=222;[I-E]
 //[I-S]LN=223;[I-E]
  public static float easeOutPower(float start, float end, float t, int n) { //[I-S]LN=224;[I-E]
    if (n <= 1) return linear(start, end, t); //[I-S]LN=225;[I-E]
    return start + (end - start) * (1.0f - (float) Math.pow(1.0f - t, n)); //[I-S]LN=226;[I-E]
  } //[I-S]LN=227;[I-E]
 //[I-S]LN=228;[I-E]
  public static float easeInOutPower(float start, float end, float t, int n) { //[I-S]LN=229;[I-E]
    if (n <= 1) return linear(start, end, t); //[I-S]LN=230;[I-E]
    t *= 2.0f; //[I-S]LN=231;[I-E]
    if (t < 1.0f) return start + (end - start) / 2.0f * (float) Math.pow(t, n); //[I-S]LN=232;[I-E]
    t -= 1.0f; //[I-S]LN=233;[I-E]
    return start + (end - start) / 2.0f * (1.0f - (float) Math.pow(1.0f - t, n) + 1.0f); //[I-S]LN=234;[I-E]
  } //[I-S]LN=235;[I-E]
 //[I-S]LN=236;[I-E]
  public static float cubicBezier(float start, float end, float t, float x1, float y1, float x2, float y2) { //[I-S]LN=237;[I-E]
    t = clamp01(t); //[I-S]LN=238;[I-E]
    float diff = end - start; //[I-S]LN=239;[I-E]
    if (x1 == y1 && x2 == y2 && x1 == x2) { //[I-S]LN=240;[I-E]
      return start + diff * t; //[I-S]LN=241;[I-E]
    } //[I-S]LN=242;[I-E]
    float lower = 0.0f; //[I-S]LN=243;[I-E]
    float upper = 1.0f; //[I-S]LN=244;[I-E]
    float u = t; //[I-S]LN=245;[I-E]
    for (int i = 0; i < 24; i++) { //[I-S]LN=246;[I-E]
      u = (lower + upper) * 0.5f; //[I-S]LN=247;[I-E]
      float xAtU = cubicBezierSample(u, x1, x2); //[I-S]LN=248;[I-E]
      if (xAtU > t) upper = u; //[I-S]LN=249;[I-E]
      else lower = u; //[I-S]LN=250;[I-E]
    } //[I-S]LN=251;[I-E]
    float yAtU = cubicBezierSample(u, y1, y2); //[I-S]LN=252;[I-E]
    return start + diff * yAtU; //[I-S]LN=253;[I-E]
  } //[I-S]LN=254;[I-E]
 //[I-S]LN=255;[I-E]
  private static float cubicBezierSample(float u, float c1, float c2) { //[I-S]LN=256;[I-E]
    float inv = 1.0f - u; //[I-S]LN=257;[I-E]
    float a = 3.0f * inv * inv * u * c1; //[I-S]LN=258;[I-E]
    float b = 3.0f * inv * u * u * c2; //[I-S]LN=259;[I-E]
    float c = u * u * u; //[I-S]LN=260;[I-E]
    return a + b + c; //[I-S]LN=261;[I-E]
  } //[I-S]LN=262;[I-E]
 //[I-S]LN=263;[I-E]
  private static float deterministicNoise(int i) { //[I-S]LN=264;[I-E]
    float x = Math.sin((float) i * 127.1f) * 43758.5453f; //[I-S]LN=265;[I-E]
    float frac = x - Math.floor(x); //[I-S]LN=266;[I-E]
    return (float) frac; //[I-S]LN=267;[I-E]
  } //[I-S]LN=268;[I-E]
}  //[I-S]LN=269;[I-E]
//C-R:EasingTypes
/* @Author Dhanu */ //[I-S]LN=0;[I-E]
enum EasingTypes { //[I-S]LN=1;[I-E]
  Linear, //[I-S]LN=2;[I-E]
  EaseInQuad, //[I-S]LN=3;[I-E]
  EaseOutQuad, //[I-S]LN=4;[I-E]
  EaseInOutQuad, //[I-S]LN=5;[I-E]
  EaseInCubic, //[I-S]LN=6;[I-E]
  EaseOutCubic, //[I-S]LN=7;[I-E]
  EaseInOutCubic, //[I-S]LN=8;[I-E]
  EaseInQuart, //[I-S]LN=9;[I-E]
  EaseOutQuart, //[I-S]LN=10;[I-E]
  EaseInOutQuart, //[I-S]LN=11;[I-E]
  EaseInQuint, //[I-S]LN=12;[I-E]
  EaseOutQuint, //[I-S]LN=13;[I-E]
  EaseInOutQuint, //[I-S]LN=14;[I-E]
  EaseInSine, //[I-S]LN=15;[I-E]
  EaseOutSine, //[I-S]LN=16;[I-E]
  EaseInOutSine, //[I-S]LN=17;[I-E]
  EaseInExpo, //[I-S]LN=18;[I-E]
  EaseOutExpo, //[I-S]LN=19;[I-E]
  EaseInOutExpo, //[I-S]LN=20;[I-E]
  EaseInCirc, //[I-S]LN=21;[I-E]
  EaseOutCirc, //[I-S]LN=22;[I-E]
  EaseInOutCirc, //[I-S]LN=23;[I-E]
  EaseInBack, //[I-S]LN=24;[I-E]
  EaseOutBack, //[I-S]LN=25;[I-E]
  EaseInOutBack, //[I-S]LN=26;[I-E]
  EaseOutBounce, //[I-S]LN=27;[I-E]
  EaseInBounce, //[I-S]LN=28;[I-E]
  EaseInOutBounce, //[I-S]LN=29;[I-E]
  EaseInElastic, //[I-S]LN=30;[I-E]
  EaseOutElastic, //[I-S]LN=31;[I-E]
  EaseInOutElastic, //[I-S]LN=32;[I-E]
  SmoothStep, //[I-S]LN=33;[I-E]
  SmootherStep, //[I-S]LN=34;[I-E]
  Step, //[I-S]LN=35;[I-E]
  EaseInPower, //[I-S]LN=36;[I-E]
  EaseOutPower, //[I-S]LN=37;[I-E]
  EaseInOutPower, //[I-S]LN=38;[I-E]
  CubicBezier //[I-S]LN=39;[I-E]
}  //[I-S]LN=40;[I-E]
//C-R:Mathf
final class Mathf { //[I-S]LN=0;[I-E]
 //[I-S]LN=1;[I-E]
  private Mathf() {} //[I-S]LN=2;[I-E]
 //[I-S]LN=3;[I-E]
  public static final float PI = 3.1415927f; //[I-S]LN=4;[I-E]
  public static final float DEG2RAD = PI / 180f; //[I-S]LN=5;[I-E]
  public static final float RAD2DEG = 180f / PI; //[I-S]LN=6;[I-E]
  public static final float E = 2.7182818f; //[I-S]LN=7;[I-E]
  public static final float EPSILON = 1.1920929E-7f; //[I-S]LN=8;[I-E]
  public static final float INFINITY = Float.POSITIVE_INFINITY; //[I-S]LN=9;[I-E]
  public static final float NEGATIVE_INFINITY = Float.NEGATIVE_INFINITY; //[I-S]LN=10;[I-E]
  public static final float HALF_PI = PI / 2f; //[I-S]LN=11;[I-E]
  public static final float TWO_PI = 2 * PI; //[I-S]LN=12;[I-E]
  public static final float SQRT2 = 1.4142135f; //[I-S]LN=13;[I-E]
  public static final float SQRT3 = 1.7320508f; //[I-S]LN=14;[I-E]
  public static final float GOLDEN_RATIO = 1.618034f; //[I-S]LN=15;[I-E]
  public static final float LN2 = 0.6931472f; //[I-S]LN=16;[I-E]
  public static final float LN10 = 2.3025851f; //[I-S]LN=17;[I-E]
  private static long lastTimeNano = java.lang.System.nanoTime(); //[I-S]LN=18;[I-E]
  private static float lastTimeSeconds = java.lang.System.nanoTime() / 1000000000f;  //[I-S]LN=19;[I-E]
   //[I-S]LN=20;[I-E]
  // Methods //[I-S]LN=21;[I-E]
  public static float abs(float v) { //[I-S]LN=22;[I-E]
    return v < 0 ? -v : v; //[I-S]LN=23;[I-E]
  } //[I-S]LN=24;[I-E]
 //[I-S]LN=25;[I-E]
  public static int abs(int v) { //[I-S]LN=26;[I-E]
    return v < 0 ? -v : v; //[I-S]LN=27;[I-E]
  } //[I-S]LN=28;[I-E]
 //[I-S]LN=29;[I-E]
  public static float acos(float f) { //[I-S]LN=30;[I-E]
    return (float) Math.acos(f); //[I-S]LN=31;[I-E]
  } //[I-S]LN=32;[I-E]
 //[I-S]LN=33;[I-E]
  public static float asin(float f) { //[I-S]LN=34;[I-E]
    return (float) Math.asin(f); //[I-S]LN=35;[I-E]
  } //[I-S]LN=36;[I-E]
 //[I-S]LN=37;[I-E]
  public static float atan(float f) { //[I-S]LN=38;[I-E]
    return (float) Math.atan(f); //[I-S]LN=39;[I-E]
  } //[I-S]LN=40;[I-E]
 //[I-S]LN=41;[I-E]
  public static float atan2(float y, float x) { //[I-S]LN=42;[I-E]
    return (float) Math.atan2(y, x); //[I-S]LN=43;[I-E]
  } //[I-S]LN=44;[I-E]
 //[I-S]LN=45;[I-E]
  public static float byNanoSecond() { //[I-S]LN=46;[I-E]
    return java.lang.System.nanoTime(); //[I-S]LN=47;[I-E]
  } //[I-S]LN=48;[I-E]
 //[I-S]LN=49;[I-E]
  public static float bySecond() { //[I-S]LN=50;[I-E]
    float currentTimeSeconds = System.nanoTime() / 1000000000f; //[I-S]LN=51;[I-E]
    float deltaTime = currentTimeSeconds - lastTimeSeconds; //[I-S]LN=52;[I-E]
    lastTimeSeconds = currentTimeSeconds; //[I-S]LN=53;[I-E]
    return deltaTime; //[I-S]LN=54;[I-E]
  }  //[I-S]LN=55;[I-E]
 //[I-S]LN=56;[I-E]
  public static float ceil(float f) { //[I-S]LN=57;[I-E]
    return (float) Math.ceil(f); //[I-S]LN=58;[I-E]
  } //[I-S]LN=59;[I-E]
 //[I-S]LN=60;[I-E]
  public static float clamp(float value, float min, float max) { //[I-S]LN=61;[I-E]
    return max(min, min(value, max)); //[I-S]LN=62;[I-E]
  } //[I-S]LN=63;[I-E]
 //[I-S]LN=64;[I-E]
  public static int clamp(int value, int min, int max) { //[I-S]LN=65;[I-E]
    return Math.max(min, Math.min(value, max)); //[I-S]LN=66;[I-E]
  } //[I-S]LN=67;[I-E]
 //[I-S]LN=68;[I-E]
  public static float clamp01(float value) { //[I-S]LN=69;[I-E]
    return clamp(value, 0f, 1f); //[I-S]LN=70;[I-E]
  } //[I-S]LN=71;[I-E]
 //[I-S]LN=72;[I-E]
  public static float cos(float f) { //[I-S]LN=73;[I-E]
    return (float) Math.cos(f); //[I-S]LN=74;[I-E]
  } //[I-S]LN=75;[I-E]
 //[I-S]LN=76;[I-E]
  public static float exp(float power) { //[I-S]LN=77;[I-E]
    return (float) Math.exp(power); //[I-S]LN=78;[I-E]
  } //[I-S]LN=79;[I-E]
 //[I-S]LN=80;[I-E]
  public static float floor(float f) { //[I-S]LN=81;[I-E]
    return (float) Math.floor(f); //[I-S]LN=82;[I-E]
  } //[I-S]LN=83;[I-E]
 //[I-S]LN=84;[I-E]
  public static float lerp(float a, float b, float t) { //[I-S]LN=85;[I-E]
    return a + clamp01(t) * (b - a); //[I-S]LN=86;[I-E]
  } //[I-S]LN=87;[I-E]
 //[I-S]LN=88;[I-E]
  public static float lerpUnclamped(float a, float b, float t) { //[I-S]LN=89;[I-E]
    return a + t * (b - a); //[I-S]LN=90;[I-E]
  } //[I-S]LN=91;[I-E]
 //[I-S]LN=92;[I-E]
  public static float inverseLerp(float a, float b, float value) { //[I-S]LN=93;[I-E]
    return a != b ? clamp01((value - a) / (b - a)) : 0f; //[I-S]LN=94;[I-E]
  } //[I-S]LN=95;[I-E]
 //[I-S]LN=96;[I-E]
  public static float log(float f, float base) { //[I-S]LN=97;[I-E]
    return (float) (Math.log(f) / Math.log(base)); //[I-S]LN=98;[I-E]
  } //[I-S]LN=99;[I-E]
 //[I-S]LN=100;[I-E]
  public static float log(float f) { //[I-S]LN=101;[I-E]
    return (float) Math.log(f); //[I-S]LN=102;[I-E]
  } //[I-S]LN=103;[I-E]
 //[I-S]LN=104;[I-E]
  public static float log10(float f) { //[I-S]LN=105;[I-E]
    return (float) Math.log10(f); //[I-S]LN=106;[I-E]
  } //[I-S]LN=107;[I-E]
 //[I-S]LN=108;[I-E]
  public static float max(float a, float b) { //[I-S]LN=109;[I-E]
    return a > b ? a : b; //[I-S]LN=110;[I-E]
  } //[I-S]LN=111;[I-E]
 //[I-S]LN=112;[I-E]
  public static int max(int a, int b) { //[I-S]LN=113;[I-E]
    return a > b ? a : b; //[I-S]LN=114;[I-E]
  } //[I-S]LN=115;[I-E]
 //[I-S]LN=116;[I-E]
  public static float min(float a, float b) { //[I-S]LN=117;[I-E]
    return a < b ? a : b; //[I-S]LN=118;[I-E]
  } //[I-S]LN=119;[I-E]
 //[I-S]LN=120;[I-E]
  public static int min(int a, int b) { //[I-S]LN=121;[I-E]
    return a < b ? a : b; //[I-S]LN=122;[I-E]
  } //[I-S]LN=123;[I-E]
 //[I-S]LN=124;[I-E]
  public static float pow(float f, float p) { //[I-S]LN=125;[I-E]
    return (float) Math.pow(f, p); //[I-S]LN=126;[I-E]
  } //[I-S]LN=127;[I-E]
 //[I-S]LN=128;[I-E]
  public static float repeat(float t, float length) { //[I-S]LN=129;[I-E]
    return t - floor(t / length) * length; //[I-S]LN=130;[I-E]
  } //[I-S]LN=131;[I-E]
 //[I-S]LN=132;[I-E]
  public static float round(float f) { //[I-S]LN=133;[I-E]
    return (float) Math.round(f); //[I-S]LN=134;[I-E]
  } //[I-S]LN=135;[I-E]
 //[I-S]LN=136;[I-E]
  public static int roundToInt(float f) { //[I-S]LN=137;[I-E]
    return (int) Math.round(f); //[I-S]LN=138;[I-E]
  } //[I-S]LN=139;[I-E]
 //[I-S]LN=140;[I-E]
  public static float sign(float f) { //[I-S]LN=141;[I-E]
    return f >= 0f ? 1f : -1f; //[I-S]LN=142;[I-E]
  } //[I-S]LN=143;[I-E]
 //[I-S]LN=144;[I-E]
  public static float sin(float f) { //[I-S]LN=145;[I-E]
    return (float) Math.sin(f); //[I-S]LN=146;[I-E]
  } //[I-S]LN=147;[I-E]
 //[I-S]LN=148;[I-E]
  public static float sqrt(float f) { //[I-S]LN=149;[I-E]
    return (float) Math.sqrt(f); //[I-S]LN=150;[I-E]
  } //[I-S]LN=151;[I-E]
 //[I-S]LN=152;[I-E]
  public static float tan(float f) { //[I-S]LN=153;[I-E]
    return (float) Math.tan(f); //[I-S]LN=154;[I-E]
  } //[I-S]LN=155;[I-E]
 //[I-S]LN=156;[I-E]
  public static float moveTowards(float current, float target, float maxDelta) { //[I-S]LN=157;[I-E]
    if (abs(target - current) <= maxDelta) return target; //[I-S]LN=158;[I-E]
    return current + sign(target - current) * maxDelta; //[I-S]LN=159;[I-E]
  } //[I-S]LN=160;[I-E]
 //[I-S]LN=161;[I-E]
  public static float deltaAngle(float current, float target) { //[I-S]LN=162;[I-E]
    float delta = repeat((target - current), 360f); //[I-S]LN=163;[I-E]
    if (delta > 180f) delta -= 360f; //[I-S]LN=164;[I-E]
    return delta; //[I-S]LN=165;[I-E]
  } //[I-S]LN=166;[I-E]
 //[I-S]LN=167;[I-E]
  public static float smoothStep(float from, float to, float t) { //[I-S]LN=168;[I-E]
    t = clamp01(t); //[I-S]LN=169;[I-E]
    t = t * t * (3f - 2f * t); //[I-S]LN=170;[I-E]
    return from + (to - from) * t; //[I-S]LN=171;[I-E]
  } //[I-S]LN=172;[I-E]
 //[I-S]LN=173;[I-E]
  public static float gamma(float value, float absmax, float gamma) { //[I-S]LN=174;[I-E]
    boolean negative = value < 0f; //[I-S]LN=175;[I-E]
    float absval = abs(value); //[I-S]LN=176;[I-E]
    if (absval > absmax) return value; //[I-S]LN=177;[I-E]
    float result = (float) Math.pow(absval / absmax, gamma) * absmax; //[I-S]LN=178;[I-E]
    return negative ? -result : result; //[I-S]LN=179;[I-E]
  } //[I-S]LN=180;[I-E]
 //[I-S]LN=181;[I-E]
  public static boolean approximately(float a, float b) { //[I-S]LN=182;[I-E]
    return Mathf.abs(b - a) < Mathf.max(1E-06f * Mathf.max(Mathf.abs(a), Mathf.abs(b)), EPSILON); //[I-S]LN=183;[I-E]
  } //[I-S]LN=184;[I-E]
 //[I-S]LN=185;[I-E]
  public static float pingPong(float t, float length) { //[I-S]LN=186;[I-E]
    t = repeat(t, length * 2f); //[I-S]LN=187;[I-E]
    return length - abs(t - length); //[I-S]LN=188;[I-E]
  } //[I-S]LN=189;[I-E]
 //[I-S]LN=190;[I-E]
  public static float nextPowerOfTwo(float f) { //[I-S]LN=191;[I-E]
    int v = (int) f; //[I-S]LN=192;[I-E]
    v--; //[I-S]LN=193;[I-E]
    v |= v >> 1; //[I-S]LN=194;[I-E]
    v |= v >> 2; //[I-S]LN=195;[I-E]
    v |= v >> 4; //[I-S]LN=196;[I-E]
    v |= v >> 8; //[I-S]LN=197;[I-E]
    v |= v >> 16; //[I-S]LN=198;[I-E]
    v++; //[I-S]LN=199;[I-E]
    return v; //[I-S]LN=200;[I-E]
  } //[I-S]LN=201;[I-E]
 //[I-S]LN=202;[I-E]
  public static boolean isPowerOfTwo(int value) { //[I-S]LN=203;[I-E]
    return (value != 0) && ((value & (value - 1)) == 0); //[I-S]LN=204;[I-E]
  } //[I-S]LN=205;[I-E]
 //[I-S]LN=206;[I-E]
  public static float degToRad(float degrees) { //[I-S]LN=207;[I-E]
    return degrees * DEG2RAD; //[I-S]LN=208;[I-E]
  } //[I-S]LN=209;[I-E]
 //[I-S]LN=210;[I-E]
  public static float radToDeg(float radians) { //[I-S]LN=211;[I-E]
    return radians * RAD2DEG; //[I-S]LN=212;[I-E]
  } //[I-S]LN=213;[I-E]
 //[I-S]LN=214;[I-E]
  public static float frac(float f) { //[I-S]LN=215;[I-E]
    return f - floor(f); //[I-S]LN=216;[I-E]
  } //[I-S]LN=217;[I-E]
 //[I-S]LN=218;[I-E]
  public static int signInt(int i) { //[I-S]LN=219;[I-E]
    return i >= 0 ? 1 : -1; //[I-S]LN=220;[I-E]
  } //[I-S]LN=221;[I-E]
 //[I-S]LN=222;[I-E]
  public static float toRadians(float degrees) { //[I-S]LN=223;[I-E]
    return (float) Math.toRadians(degrees); //[I-S]LN=224;[I-E]
  } //[I-S]LN=225;[I-E]
 //[I-S]LN=226;[I-E]
  public static float toDegrees(float radians) { //[I-S]LN=227;[I-E]
    return (float) Math.toDegrees(radians); //[I-S]LN=228;[I-E]
  } //[I-S]LN=229;[I-E]
 //[I-S]LN=230;[I-E]
  public static float average(float... values) { //[I-S]LN=231;[I-E]
    if (values.length == 0) return 0f; //[I-S]LN=232;[I-E]
    float sum = 0f; //[I-S]LN=233;[I-E]
    for (float v : values) sum += v; //[I-S]LN=234;[I-E]
    return sum / values.length; //[I-S]LN=235;[I-E]
  } //[I-S]LN=236;[I-E]
 //[I-S]LN=237;[I-E]
  public static float distance(float a, float b) { //[I-S]LN=238;[I-E]
    return abs(a - b); //[I-S]LN=239;[I-E]
  } //[I-S]LN=240;[I-E]
 //[I-S]LN=241;[I-E]
  public static float normalize(float value, float min, float max) { //[I-S]LN=242;[I-E]
    return (value - min) / (max - min); //[I-S]LN=243;[I-E]
  } //[I-S]LN=244;[I-E]
 //[I-S]LN=245;[I-E]
  public static float map(float value, float inMin, float inMax, float outMin, float outMax) { //[I-S]LN=246;[I-E]
    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin)); //[I-S]LN=247;[I-E]
  } //[I-S]LN=248;[I-E]
} //[I-S]LN=249;[I-E]
//C-R:Test
class Test extends Component {
   /* @Author Dhanu */ //[I-S]LN=0;[I-E]
   public enum Mode { //[I-S]LN=1;[I-E]
     P, //[I-S]LN=2;[I-E]
     R, //[I-S]LN=3;[I-E]
     S //[I-S]LN=4;[I-E]
   } //[I-S]LN=5;[I-E]
    //[I-S]LN=6;[I-E]
   public Mode mode = Mode.P; //[I-S]LN=7;[I-E]
   public float time, duration; //[I-S]LN=8;[I-E]
    //[I-S]LN=9;[I-E]
   public Vector3 start = new Vector3(); //[I-S]LN=10;[I-E]
   public Vector3 end = new Vector3(); //[I-S]LN=11;[I-E]
   public Text3D text; //[I-S]LN=12;[I-E]
    //[I-S]LN=13;[I-E]
   public EasingTypes type; //[I-S]LN=14;[I-E]
   public Curve curve = new Curve(); //[I-S]LN=15;[I-E]
    //[I-S]LN=16;[I-E]
   public boolean useCurve; //[I-S]LN=17;[I-E]
   /// Run only once //[I-S]LN=18;[I-E]
public    void start() {} //[I-S]LN=19;[I-E]
    //[I-S]LN=20;[I-E]
   /// Repeat every frame //[I-S]LN=21;[I-E]
public    void repeat() { //[I-S]LN=22;[I-E]
     if (time < duration) { //[I-S]LN=23;[I-E]
       time += Math.bySecond(); //[I-S]LN=24;[I-E]
     } //[I-S]LN=25;[I-E]
    //[I-S]LN=26;[I-E]
     float t = Mathf.normalize(time / (duration), 0f, 1f); //[I-S]LN=27;[I-E]
     switch (mode) { //[I-S]LN=28;[I-E]
       case P: //[I-S]LN=29;[I-E]
         if (useCurve) myTransform.setPosition(Easer.easeVec(start, end, t, curve)); //[I-S]LN=30;[I-E]
         else myTransform.setPosition(Easer.easeVec(start, end, t, curve)); //[I-S]LN=31;[I-E]
         break; //[I-S]LN=32;[I-E]
       case R: //[I-S]LN=33;[I-E]
         if (useCurve) myTransform.setRotation(Easer.easeQua(start, end, t, curve)); //[I-S]LN=34;[I-E]
         else myTransform.setRotation(Easer.easeQua(start, end, t, type)); //[I-S]LN=35;[I-E]
         break; //[I-S]LN=36;[I-E]
       case S: //[I-S]LN=37;[I-E]
         if (useCurve) myTransform.setScale(Easer.easeVec(start, end, t, curve)); //[I-S]LN=38;[I-E]
         else myTransform.setScale(Easer.easeVec(start, end, t, type)); //[I-S]LN=39;[I-E]
         break; //[I-S]LN=40;[I-E]
       default: //[I-S]LN=41;[I-E]
     }  //[I-S]LN=42;[I-E]
    //[I-S]LN=43;[I-E]
     text.setText(new String().format("%.2f", time)); //[I-S]LN=44;[I-E]
   } //[I-S]LN=45;[I-E]
}